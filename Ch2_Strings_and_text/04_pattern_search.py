"""
    Задача. Мы хотим отыскать совпадение или произвести поиск по определенному шаблону.
"""
import re

text = 'yeah, but no, but yeah, but no, but yeah'
# Точное совпадении
print(f'Exact match:: {text == "yeah"}')

# Совпадение по началу или концу
print(f'Start match:: {text.startswith("yeah")}')
print(f'Match at the end:: {text.endswith("no")}')

# Поиск места первого вхождения
print(f'First occurrence:: {text.find("no")}')
print('-'*20)

"""
    Примечание. Для более сложного поиска совпадений используйте регулярные выражения и модуль re.
"""
text1 = '11/27/2012'
text2 = 'Nov 27, 2012'

# Простое сопоставление: \d+ означает совпадение одной или более цифр
if re.match(r'\d+/\d+/\d+', text1):
    print('yes')
else:
    print('no')

if re.match(r'\d+/\d+/\d+', text2):
    print('yes')
else:
    print('no')
print('-'*20)
"""
    Примечание. Если мы собираемся много раз искать по одному и тому же шаблону, часто окупается предварительная 
    компиляция шаблона регулярного выражения в объект шаблона.
"""
datepat = re.compile(r'\d+/\d+/\d+')
for t in [text1, text2]:
    pass
if datepat.match(t):
    print('yep')
else:
    print('nope')

# match() ищет совпадение в начале строки! Если мы хотим провести поиск по всем случаям соответствия шаблону,
# необходимо использовать findall().
text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
print(f'Findall:: {datepat.findall(text)}')
print('-'*20)

"""
    Примечание. Захватывающие группы нередко упрощают последующую обработку найденного текста, поскольку содержимое 
    группы может быть извлечено отдельно.
"""
datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
m = datepat.match('11/27/2012')
print(m)    # <re.Match object; span=(0, 10), match='11/27/2012'>
# Извлекаем содержимое каждой группы
for i in range(0, 4):
    print(f'Group {i}:: {m.group(i)}')

print(f'All groups:: {m.groups()=}')
month, day, year = m.groups()
print(f'Unpacking:: {month=}, {day=}, {year=}')
print('-'*20)

# Найти все совпадения(обрати внимание на разрезание на кортежи)
all_match = datepat.findall(text)
print(f'All match:: {all_match}')
for month, day, year in datepat.findall(text):
    print('{}-{}-{}'.format(year, month, day))
print('-'*20)

"""
    Примечание.Метод findall() проходит по тексту и находит все совпадения, возвращая их в списке! Если нам 
    необходимо искать совпадения итеративно, то необходимо  использовать метод finditer().
"""
for m in datepat.finditer(text):
    print(m.groups())
print('-'*20)

"""
    Примечание.Метод match() проверяет только начало строки и возможно он найдет вещи которых вы не ожидаете!
"""
m = datepat.match('11/27/2012asdfh')
print(m.group())
# Если необходимо точное совпадение, убедитесь, что шаблон включает символ завершения($)
datepat = re.compile(r'(\d+)/(\d+)/(\d+)\$')
m = datepat.match('11/27/2012asdfh')
print(f'{m=}')
print(datepat.match('11/27/2012'))

# Если вы проводите простые операции поиска, вы часто можете пропустить шаг компиляции и использовать функции уровня
# модуля из модуля re
print(re.findall(r'(\d+)/(\d+)/(\d+)', text))
"""
    Примечание. Обрати внимание, если мы проводим много операций поиска совпадений, часто окупается компилирование 
    шаблона и многократное его использование! Функции уровня модуля поддерживают кеш недавно скомпилированных шаблонов, 
    так что мы не получим огромного выигрыша в производительности, но сэкономите несколько обращений и избежите лишней 
    обработки, используя ваш собственный скомпилированный шаблон.
"""